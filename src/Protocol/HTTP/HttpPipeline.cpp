#include "HttpPipeline.h"

HttpRequestQueue::HttpRequestQueue(RxConnection *conn):_conn(conn)
{
    this->prepare_for_next_request();
}

bool HttpRequestQueue::empty() const
{
    return _pipeline.empty();
}

HttpRequestQueue::PipelineNode &HttpRequestQueue::front()
{
    return _pipeline.front();
}

HttpRequestQueue::PipelineNode &HttpRequestQueue::back()
{
    return _pipeline.back();
}

size_t HttpRequestQueue::pending_request_num() const
{
    return _pipeline.size()-1;
}

void HttpRequestQueue::prepare_for_next_request()
{
    _pipeline.push(PipelineNode(_conn));
}

void HttpRequestQueue::queue_req_handler(const HttpReqHandler &req_handler)
{
    if(req_handler){
         _pipeline.back().pending_req_handlers.push(req_handler);
    }
}


/// \brief
/// any req_handler may use defer_content_provider in HttpResponse to provide content to output buffer,
/// so we should check if there exists defer content provider set by previous req_handler,
/// if so, we must wait it to finish before we execute following request handler in the handlers' queue
bool HttpRequestQueue::try_handle_one()
{
    if(this->pending_request_num()!=0){
        PipelineNode &pipe_node=_pipeline.front();
        std::queue<HttpReqHandler> &q_pending_handler=pipe_node.pending_req_handlers;

        while(pipe_node.response.check_and_wait_content_provider()&&!q_pending_handler.empty()){
            HttpReqHandler &req_handler=q_pending_handler.front();
            req_handler(pipe_node.request,pipe_node.response);
            q_pending_handler.pop();
        }

        //send data generated by http router's handler
        pipe_node.response.flush();

        RxWriteRc rc;
        ssize_t n_send=pipe_node.request.get_connection()->send(rc);
//        std::cout<<"n_send="<<n_send<<std::endl;
        if(rc==RxWriteRc::ERROR){

        }

        //TODO　判断是否要把if语句放这里
        if(pipe_node.request.stage()==HttpReqLifetimeStage::RequestCompleted){
//            std::cout<<"!!! req complete"<<std::endl;
            HttpRequestRouter::route_request(pipe_node.request,pipe_node.response,HttpReqLifetimeStage::RequestCompleted);
            _pipeline.pop();
            return true;
        }
    }
    return false;
}

void HttpRequestQueue::try_handle_remaining()
{
    while(try_handle_one());
}
