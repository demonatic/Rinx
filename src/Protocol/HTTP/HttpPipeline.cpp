#include "HttpPipeline.h"

HttpRequestPipeline::HttpRequestPipeline(RxConnection *conn):_conn(conn)
{
    this->prepare_for_next_request();
}

bool HttpRequestPipeline::empty() const
{
    return _pipeline.empty();
}

HttpRequestPipeline::PipelineNode &HttpRequestPipeline::front()
{
    return _pipeline.front();
}

HttpRequestPipeline::PipelineNode &HttpRequestPipeline::back()
{
    return _pipeline.back();
}

size_t HttpRequestPipeline::pending_request_num() const
{
    return _pipeline.size()-1;
}

void HttpRequestPipeline::prepare_for_next_request()
{
    _pipeline.push(PipelineNode(_conn));
}

void HttpRequestPipeline::queue_req_handler(const HttpReqHandler &req_handler)
{
    _pipeline.back().pending_req_handlers.push(req_handler);
}


/// \brief
/// any req_handler may use defer_content_provider in HttpResponse to provide content to output buffer,
/// so we should check if there exists defer content provider set by previous req_handler,
/// if so, we must wait it to finish before we execute following request handler in the handlers' queue
bool HttpRequestPipeline::try_handle_one()
{
    if(this->pending_request_num()!=0){
        PipelineNode &pipe_node=_pipeline.front();
        std::queue<HttpReqHandler> &q_pending_handler=pipe_node.pending_req_handlers;

        while(pipe_node.response.check_and_wait_content_provider()&&!q_pending_handler.empty()){
            HttpReqHandler &req_handler=q_pending_handler.front();
            req_handler(pipe_node.request,pipe_node.response);
            q_pending_handler.pop();

            //send data generated by http router's handler
            //TODO: let it done manually by user?
            pipe_node.response.flush();
            //TODO check has data to send
            RxWriteRc rc;
            ssize_t n_send=pipe_node.request.get_connection()->send(rc);
            std::cout<<"n_send="<<n_send<<std::endl;
            if(rc==RxWriteRc::ERROR){

            }
        }

        //TODO　判断是否要把if语句放这里
        if(pipe_node.request.stage()==HttpReqLifetimeStage::RequestCompleted){
            std::cout<<"!!! req complete"<<std::endl;
            HttpRequestRouter::route_request(pipe_node.request,pipe_node.response,HttpReqLifetimeStage::RequestCompleted);
            _pipeline.pop();
            return true;
        }
    }
    return false;
}

void HttpRequestPipeline::try_handle_remaining()
{
    while(try_handle_one());
}
